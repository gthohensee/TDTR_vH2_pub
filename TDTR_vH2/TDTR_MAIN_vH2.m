%TDTR_MAIN_vH2 - Given system & thermal parameters, do thermal modeling.
% This script will do thermal modeling and print/save a figure representing
% the fit. It can handle manual, automatic, and manual in-phase fitting.
% It will also make sensitivity plots and error bar calculations upon 
% request.
%
% Syntax:  run this script through an analyze_yymmdd script, not
% independently, unless you define the expected variables first. I'd make
% it a function, but it expects a lot of variables.
%
% Variables expected to exist in the workspace:
%    ii              - index from the analyze script's for loop.
%                      Used to pick out stack(ii,:) for individual samples.
%    r_pump, r_probe - pump and probe spot sizes, in meters
%    tau_rep         - Ti:sapphire pulse repetition period
%    f               - pump/EOM modulation frequency
%    TCR             - thermoreflectance coefficient
%    fname           - string indicating data file name.
%    datain          - string indicating path to data file.
%    datadir         - string indicating path to data folder.
%    stack           - cell string matrix from the analyze script.
%    LCTE            - 4xM thermal parameter matrix
%    Xguess          - used in FIT and MANUALFIT functions
%    XguessIJ        - used in FIT and MANUALFIT functions
%    Xij             - used in FIT and MANUALFIT functions
%    Zdelay          - optional, starting time delay in ps from which to 
%                      plot data and evaluate goodness of fit.
%    tdelay_min      - minimum of delay time to model
%    tdelay_max      - maximum of delay time to model
%    P,T             - pressure and temperature. Set to -1 to assume ambient.
%    BI              - TRUE if bidirectional heat flow
%    n_toplayer      - thermal modeling parameter for bidirectional heat flow.
%                      indicates number of layers above the heat deposition
%                      plane in the sample.
%    Voutlinfit      - boolean, TRUE if V(out) is replaced with a linear
%                      fit to V(out), made in the process script.
%    m1,m2,fitOK     - Used if Voutlinfit = TRUE; linear fit parameters.
%                      Vout = m1*tdelay + m2, fitOK judges quality of fit.
%                      m1 should be in units of uV/ps, m2 in units of uV.
%    intscheme       - integration scheme: 0 = Legendre-Gauss, 1 = Rombint,
%                      2 = Simpson integration.
%    nnodes          - number of nodes for Legendre-Gauss integration;
%                      affects numerical accuracy. Don't go below 35 nodes
%                      unless you know what you're doing.
%    options         - tolerances for auto-fitting
%    senseplot       - Generate Sensitivity Plot? This option is available
%                      dynamically in MANUALFIT.
%    ebar            - TRUE if calculating Errorbars (takes longer).
%    importdata      - TRUE if fitting data. FALSE if just running 
%                      sensitivity plots or error bar calculations.
%    manualfit       - TRUE if fitting manually, FALSE if auto-fitting.
%    sigfit          - 1 if fitting V(in), 2 if fitting V(out), any other
%                      value will fit the ratio.
%
%
% Important products of this script:
%    Xsol - thermal parameter fit
%    fit result figure in .fig and .eps formats, saved to datadir.
%
% Other m-files required: TDTR_REFL_vH2.m, TDTR_FIT_vH2.m,
%                         TDTR_MANUALFIT_vH2.m, TDTR_TDEP_vH2.m,
%                         SS_Heating_vH2.m, TDTR_REFL_vH2.m,
%                         TDTR_TEMP_vH2.m, INITIALIZE_CELLPARAMS_vH2.m,
%                         senseplot_vH2.m, errorbars_vH2.m,
%                         errorbar_conditions_vH2.m, genLCTEtext.m,
%                         extract_interior.m, rombint_VV3.m, SimpsonInt.m,
%                         lgwt_V4.m, mtimesx package.
% Subfunctions: none
% MAT-files required: none
%
% See also: The TDTR_TTM_vH2 package

% Author: Gregory Hohensee
% Acknowledgement: code based on Joseph P. Feser's TDTR_MAIN_V4.m script.
% University of Illinois Urbana-Champaign
% email: hohense2@illinois.edu
% Website: n/a
% Revision history: 3/25/2014 - TDTR_MAIN_vH1.m
%                   4/8/2014  - comments, harmonized with TTM version
%                   6/13/2014 - hacked to support dR/dT calculation,
%                               see lines ~240-250.
%                   7/14/2014 - vH2.
%------------- BEGIN CODE --------------
%%
% I removed keepdir functionality for this version of MAIN, because this
% MAIN assumes the data folder and fnames are all generated by the
% analyze script.

%______PROGRAM OPTIONS______________________
% These are specified in the analyze script.
%___________________________________________
%%
% If you want no laser heating *and* T not at room T, just give
% writeLCTE your different T, and still set T0 = T = -1.

matparams = {LCTE aniso BI n_toplayer TCR};
sysparams = {tau_rep f r_pump r_probe};
Tparams = {T0, T_LCTE, A_pump, A_probe, absC, perpulse, jabs, jtrans};
% calparams assignment needs to wait until Zind is defined.
% datparams assignment needs to wait until tdelay and data are defined.
% If psc == TRUE (varying spot size), sysparams will be updated later,
%   after tdelay is defined.

% initialize variables relating to errorbar calculation
consider_error = 0;           % MAIN does not do error bars.
LCTE_err = zeros(size(LCTE));

% define tolerances for automatic fitting in FIT and sensitivity calculations
if ~exist('options','var'); options = optimset('TolFun',1e-2,'TolX',1e-2); end

if senseplot || ebar
    % DESIGN CHOICE: I calculate sensitivities and error bars using the
    % thermal model generated best fit to the data, as specified by LCTE,
    % NOT with respect to the data itself. This ensures that these 
    % calculations do not second-guess my judgement of the fit, are not 
    % influenced by random noise, and represent sensitivities and error 
    % bars with respect ONLY to systematic or thermal parameters.
    
    %vector of time delays (used to generate sensitivity plots)
    tdelay=logspace(log10(tdelay_min),log10(tdelay_max),20)';
    if psc % psc: TRUE if pump spot changing over time delay. Relies on
           % "frac", the fractional change, assigned in analyze script.
        r_pump = r_pump*(1 + frac*tdelay/tdelay(end));
        sysparams = {tau_rep f r_pump r_probe}; % update sysparams
    end
    
    
    [~,Zind] = min(abs(tdelay - Zdelay*1e-12));
    calparams = {Zind sigfit intscheme nnodes consider_error};
    
    
    [deltaR_data,ratio_data]=TDTR_REFL_vH2(tdelay,matparams,sysparams,A_pump,intscheme,nnodes);
    
    switch sigfit
        case 1, datparams = {tdelay Vin_data datadir};
        case 2, datparams = {tdelay Vout_data datadir};
        otherwise datparams = {tdelay ratio_data datadir}; 
    end
    
end
%-------------Generate Sensitivity Plot--------------
if senseplot
    tic
    fprintf('Calculating Sensitivities...Please Wait.\n')  
    
    % calls REFL, requres cellparams
    senseplot_vH2(datparams,sysparams, calparams, matparams, Tparams); 
    toc
    fprintf('Sensitivities calculated.\n')
end
%--------------Compute Errorbars---------------------
if ebar
    tic
    %options = optimset('TolFun',1e-1,'TolX',1e-1); % default tolerances for errorbars
    fprintf('Calculating Errorbar...Please Wait.\n')    
    % errorbars_TTM_vH2 calls FIT, requires all cellparams
    [kErr_perc, kErr_abs, ...
        ErrSummary_perc, ErrSummary_abs] = ...
        errorbars_vH2(Xijc,datparams,sysparams,...
                          calparams,matparams,Tparams,options); 
    
    % save Xsol and errorbar result to file
    dlmwrite(strcat(datadir,'Xsol_ErrSummary_perc_',filename,'.txt'),...
                    vertcat(Xsol,ErrSummary_perc));
    toc
    fprintf('Errorbar calculated.\n')
end
%% --------------Import Data---------------------------
% reads and extracts data matrix, generates Zind, checks that ratio is 
% positive, linearizes V(out) if desired.
if importdata
    DM1 = dlmread(datain);
    tdelay_raw=DM1(:,2)*1e-12; %imported in picoseconds.  Change to seconds.
    Vin_raw=DM1(:,3); 
    Vout_raw=DM1(:,4);
    ratio_raw=DM1(:,5);
    
    if exist('Vout_offset','var')
        Vout_raw = Vout_raw - Vout_offset;
        ratio_raw = -Vin_raw ./ Vout_raw;
    end
    
    if length(DM1(1,:)) > 5
        detV_raw = DM1(:,6);
    end 
    
    if exist('detV_raw','var')
        [~,detV_data] =extract_interior(tdelay_raw,detV_raw,tdelay_min,tdelay_max);
    end

    [~,ratio_data]          =extract_interior(tdelay_raw,ratio_raw, tdelay_min,tdelay_max);
    [~,Vin_data]            =extract_interior(tdelay_raw,Vin_raw,   tdelay_min,tdelay_max);
    [tdelay_data,Vout_data] =extract_interior(tdelay_raw,Vout_raw,  tdelay_min,tdelay_max);
    if psc % psc: is pump spot changing over time delay? Relies on
           % "frac", the fractional change, assigned in analyze script.
        r_pump = r_pump*(1 + frac*tdelay_data/tdelay_data(end));
        sysparams = {tau_rep f r_pump r_probe}; % update sysparams
    end
    
    % Define Zind: Zdelay = tdelay(Zind), approximately.
    [~,Zind] = min(abs(tdelay_data - Zdelay*1e-12));

    % If the analysis comes with a reasonable linear fit to V_out, 
    % use that to smooth ratio_data. [NOT TESTED]
    if exist('Voutlinfit','var') && exist('fitOK','var')
        if Voutlinfit && fitOK
            Vout_lin = m1*1e12 * tdelay_data + m2; % [m1 uV/ps]*[1e12 ps/s]*[tdelay seconds] + uV
            r_lin = -Vin_data ./ Vout_lin;
            ratio_data = r_lin;
        end
    end
            
    %% Compose remaining parameter cells, 
    % now that Zind, tdelay, and data are defined.
    switch sigfit
        case 1, datparams = {tdelay_data Vin_data datadir};
        case 2, datparams = {tdelay_data Vout_data datadir};
        otherwise datparams = {tdelay_data ratio_data datadir}; 
    end
    
    calparams = {Zind sigfit intscheme nnodes consider_error};
    
%% --------------Perform Fit--------------------------
   % Fitting assigns values to Xsol, Z, deltaR_model, ratio_model, LCTE.
   % LCTE changes if eta changes by changing L, or if the entire LCTE
   % changes from self-consistent temperature changes.
    if manualfit
        switch sigfit
            case 1, fprintf('Manual fitting to V(in)(t) normalized at %i ps...\n',tdelay_data(Zind)*1e12);
            case 2, fprintf('Manual fitting to V(out)(t) normalized near %i ps...\n',tdelay_data(Zind)*1e12);
            otherwise fprintf('Manual fitting to ratio -V(in)/V(out)...\n');
        end
        
        [Xsol,Z,deltaR_model,ratio_model,LCTE,T_adj,N] = ...
                  TDTR_MANUALFIT_vH2(XguessIJ, datparams,...
                sysparams, calparams, matparams, Tparams);
            
        XguessIJ(:,1) = Xsol;
        
    else
        Xguess = XguessIJ(:,1);
        
        fprintf('Please wait for automatic fitting...\n');
        tic
        Xsol = fminsearch(@(X) TDTR_FIT_vH2(X, Xij, datparams,...
                               sysparams, calparams, matparams, Tparams),...
                               Xguess,options);
                           
        % fminsearch doesn't output anything but Xsol, so get the rest here.                
        [Z,deltaR_model,ratio_model,LCTE,T_adj]=...
            TDTR_FIT_vH2(Xsol, Xij,datparams,sysparams,calparams,matparams,Tparams);
        toc
    end
    fprintf('Data fit completed\n');
else % not importing data, just doing errorbars, sensitivities, or making figures.
    Xsol = Xguess;
    Z = 0;
    
    % Assign tdelay, deltaR, ratio models to the model reference "data"
    % from the sensitivity and error bar calculations.
    tdelay_data = tdelay;
    deltaR_model = deltaR_data;
    ratio_model = ratio_data;
    T_adj = 0;
end

%% Hack to include dR/dT estimation: outputs are dT0 and Vin0, vs. tdelay_data %
if get_dRdT == 1    
    % dT here removes conversion to dR (dR = TCR * dT), and
    % scales dT to be dT per unit pump power absorbed, which I can
    % then re-apply using A0 = 2(1-R)*A_pump/pi.
    dT0 = real(deltaR_model) / (TCR * A_pump);
    Vin0 = (Vin_data*1e-6) ./ (detV_data * 1e-3); % SI units, from uV/mV
    % Vin_data ./ (detV * dT0) is part of the dR/dT calculation.
    % You can index by tdelay_data for the appropriate delay time to apply
    % the dR/dT calculation.
    dlnRdT = Vin0 ./ dT0;
end
% % end hack % %

%% --------------Generate save data --------------------
% saves last fit (tdelay_data, ratio_model)
% uses saveres
% uses fname for results
% uses Vin_data, ratio_data
% saves a sensitivity plot, if you asked for it in the analyze script.
dlmwrite('last_fit.txt',[tdelay_data*1e12,ratio_model],'delimiter','\t')

saveres=input('Want to save results? (0=no, 1=yes): ');
%saveres = 1;  % TRUE to save fit result figure and/or sensitivity figure.

if saveres
    figsens = 202;
    figfit = 203;
 
    % Save the workspace
    save(strcat(datadir,'Results_', fname(1:end-4),'.mat'))
    
    % define the data and model arrays for the results figure
    switch sigfit
        case 1
            plot_data = Vin_data / Vin_data(Zind);
            plot_model = real(deltaR_model);
            plot_model = plot_model / (plot_model(Zind)/N); % see MANUALFIT for N
            ytext = 'normalized V(in)';
            fittext = 'FITVin_';
        case 2
            plot_data = Vout_data / Vout_data(Zind);
            plot_model = imag(deltaR_model);
            plot_model = plot_model / (plot_model(Zind)/N);
            ytext = 'normalized V(out)';
            fittext = 'FITVout_';
        otherwise
            plot_data = ratio_data;
            plot_model = ratio_model;
            ytext = '-V(in)/V(out)';
            fittext = 'FIT_';
    end
    
    % Create a figure for the last fit
    figure(figfit)
    clf;
    
    if importdata
        hd = loglog(tdelay_data,plot_data,'ko');
        hold on;
        hm = loglog(tdelay_data,plot_model,'k-');
        hold off;
    else % if importdata is false, then we didn't fit anything,
         % so there's no data points to plot -- just the model.
        hm = loglog(tdelay_data,plot_model,'k-');
    end
    set(hm,'LineWidth',2)
    fontsize = 16;
    if P0 ~= -1
        if exist('frac','var') && length(r_pump) > 1
            condtext = sprintf('P = %0.1f GPa, dR_{pump} = %i%%, Z = %0.2d, t_{fit} = %i ps',P0,frac*100,Z,Zdelay);
        else
            condtext = sprintf('P = %0.1f GPa, Z = %0.2d, t(fit) = %i ps',P0,Z,Zdelay);
        end
    elseif T0 ~= -1
        if exist('frac','var') && length(r_pump) > 1
            condtext = sprintf('T = %0.1f K, dR_{pump} = %i%%, Z = %0.2d, t_{fit} = %i ps',T0,frac*100,Z,Zdelay);
        else
            condtext = sprintf('T = %0.1f K, Z = %0.2d, t(fit) = %i ps',T0,Z,Zdelay);
        end
    else
        condtext = sprintf('dR_{pump} = %i%%, Z = %0.2d, t_{fit} = %i ps',frac*100,Z,Zdelay);
    end
    if sigfit ~= 2
        set(gca, 'YTick', [0.01 0.02 0.05 0.1 0.2 0.5 1 2 5 10 20 30 50]);
        axis([tdelay_min 5e-9 min(0.1,min(plot_data)) 2*max(plot_data)])
    else
        set(gca,'YScale','linear');
        set(gca, 'YTick', [0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8 2]);
        axis([tdelay_min 5e-9 min(0,min(plot_data)) 2])
        
    end
    xlabel('time delay (ps)','FontSize',fontsize)
    ylabel(ytext, 'FontSize',fontsize)
    title(condtext,'FontSize',fontsize)
    
    set(gca, 'XTick', [1e-11 2e-11 5e-11 1e-10,2e-10,5e-10,1e-9,2e-9,5e-9,1e-8]);
    set(gca, 'XTickLabel', [10 20 50 100, 200, 500, 1000, 2000, 5000, 1e4]);
    set(gca, 'XMinorTick', 'off');
    set(gca, 'YMinorTick', 'off');
    set(gca, 'TickLength' , [.02 .02]);
    set(gca,'FontSize',fontsize);
    %% Provide a summary of final fit parameters in the figure.
    
    % Warning: uses "ii" index from the analyze script's for loop!
    % Compose fitstr and update LCTsol to match Xsol
    XsolIJ = XguessIJ;
    XsolIJ(:,1) = Xsol';
    LCTEtext = genLCTEtext(LCTE, XsolIJ, stack(ii,:));
    
    % write LCTEstr contents to a text box in the figure
    pBox = annotation('textbox',[0.15,0.15,0.8,0.3]);
    set(pBox,'Units','characters')
    set(pBox,'HorizontalAlignment','left')
    set(pBox,'FontSize',12)
    set(pBox,'String',LCTEtext);
    set(pBox,'LineStyle','none');
    
    % also record the data file used
    dBox = annotation('textbox',[0.15,0.85,0.8,0.07]);
    set(dBox,'Units','characters')
    set(dBox,'Interpreter','none')
    set(dBox,'HorizontalAlignment','left')
    set(dBox,'FontSize',12)
    set(dBox,'String',{'Data file:'; fname(1:end-4)});
    set(dBox,'LineStyle','none');
    
    %% Save the figure to .fig and .eps files
    saveas(figfit, strcat(datadir,fittext,fname(1:end-4),'.fig'))
    print(figfit,'-depsc',strcat(datadir,fittext,fname(1:end-4),'.eps'))
    
    if senseplot
        tag = input('Name the sensitivity plot: ','s');
        save(strcat(datadir,'/SENS_', tag, '.mat'))
        figure(figsens)
        saveas(figsens, strcat(datadir,'/SENS_',tag,'.fig'))
        print(figsens,'-depsc',strcat(datadir,'/SENS_',tag,'.eps'))
    end
end
%% ----------------------------------------------------
fprintf('Program Completed\n')
beep
pause(0.1);
beep
pause(0.1);
beep
%---------------- END OF CODE -----------------------